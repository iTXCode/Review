### 布隆过滤器:概率性,多个位图的位置确定信息的存在与否

- 存在:不确定
- 不存在:正确

### 一级空间配置器:处理大于128字节空间的申请释放
 - 封装了malloc,free
 - new_handler机制:(有应对措施,就执行.没有就结束或者抛异常)处理空间不足的应对措施
 - 空间不足的时候会有一个死循环,死循环内部再次调用malloc申请空间
 - 如果申请成功,返回.否则继续循环

### 二级空间配置器:处理<=128 byte 字节的空间申请和释放
- 内存池+哈希桶

### 内存池:提前申请的一大块备用空间
#### 申请空间
- 使用指针标记出内存池的开始与结束位置
- 若有内存申请,将指向内存池开始位置的指针向后移动所申请的位数
- 并将申请的资源给予申请对象
#### 释放空间
- 使用链表将已经分配给对象的原内存池空间链接起来
- 再次申请空间的时候,可以继续从内存池中拿取
- 也可以到往链表中获取,
#### 哈希桶:用来管理你已经申请过的空间的
- [ ] 有16个桶,每一个桶以8byte向上递增
- 申请4个字节的话,会先向上对齐到8字节,然后进行申请
- [ ]申请的n < = 128字节:二级空间配置器
1.向上取整到[n]对齐到8的整数倍-->哈希桶的一个位置
2.查看当前位置是否有内存块
   有:将第一块空间给予申请对象,将剩余的挂到对应的位置
   没有:向内存池所要空间,chunk_alloc(n,nobj)
        内存池剩余空间:left=_end-_start;
        索要总的内存:totalByte=n*nobj;
        if(left>=totalByte){
          直接从内存池获取空间
        }
       if(left<totalByte){
         if(left>n){
           至少有一块;
         nobj=left/n;
         给哈希桶nboj块内存

         }

           if(left<n){
             不足一块;
             向上对齐:挂到对应的哈希桶
             向系统申请空间
                成功:放入内存池,递归:chunk(n,nobj);
                申请失败:系统没有空间了,去查看哈希桶中有没有比申请的空间更大的内存块
                  有:取一块放入内存池,递归:chunk(n,nobj);
                  没有:调用一级空间配置器
           }
        }
   
   第一块分配给用户,剩余挂到对应的桶位置
   二级空间配置器
     第一个位置:哈希桶
     第二个位置:内存池
     第三个位置:系统
     第四个位置:更大的哈希桶
     第五个位置:一级空间配置器
 

 默认:二级空间配置器
  释放:n>128byte:一级空间配置器释放
       n<=128byte:哈希桶回收
 simple_alloc:封装空间配置器,调用成本低
 容器:simple_alloc
      空间配置器:只负责申请释放空间,不进行初始化和资源清理
      初始化:construct-->new定位表达式-->显示掉哦那个构造函数
      资源:destory-->清理空间
